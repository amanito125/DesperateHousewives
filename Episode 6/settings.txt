 public void Push(T element)
        {
            this.firstNode = new Node<T>(element, this.firstNode);
            this.Count++;
        }


Губим възможността за произволен достъп. Няма начин, по който да индексираме k-тия елемент, без да минем през всички k-1 предходни. [Динамична имплементация]

Реализация на списък чрез масив, който автоматично увеличава размера си при нужда. [Статична имплементация]

Операциите добавяне и премахване от вътрешността  на списъка изискват пренареждане на елементите. [Статична имплементация]

Операциите добавяне и премахване от вътрешността  на списъка е бърза операция. [Динамична имплементация]

Търсенето на елементите в него е сравнително бърза операция. [Статична имплементация]

При често добавяне и премахване (особено при голям брой елементи) това може да доведе до ниска производителност. [Статична имплементация]

Можем да поддържаме паметта точно колкото ни трябва като сложността на добавяне си остава. [Динамична имплементация]

Елементите съдържат само конкретния обект. [Статична имплементация]

Всеки елемент съдържа променлива и указател, сочещ към следващия елемент. [Динамична имплементация]



public void Add(object element)
        {
            //ако броя на елементите ни е 0, т.е. ако няма елементи в списъка 
            if(count == 0)
            {
                //създаваме си един нов нод с елемента, който ни се подава
                Node newNode = new Node(element);
                //в такъв случай и началото и края ще са равни на този нов нод
                head = newNode;
                tail = newNode;
                //и броя на елементите ни се увеличава
                count++;
            }
            //в противен случай, ако вече имаме елементи в нашия списък
            else
            {
                //вече ще ползваме конструктора на класа Node на който подаваме елемента и опашката(предишния нод), или 
                //последния елемент в нашия списък
                Node newNode = new Node(element, tail);
                //казваме на последния елемент, че вече ще бъде равен на този нов нод
                tail = newNode;
                //и увеличаваме броя на елементите в нашия списък
                count++;
            }
        }



Pop трябва да връща и премахва елемент най-горе в стека, не по индекс. Ще оправим грешката като не приемаме index като параметър на метода Pop и вместо T element = this.items[index] ще взимаме последно добавения елемент чрез Last() - this.items.Last()